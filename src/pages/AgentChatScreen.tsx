import { useState, useCallback } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { Plus } from 'lucide-react';
import { TopBar } from '@/components/layout/TopBar';
import { ScreenContainer } from '@/components/layout/ScreenContainer';
import { ThreadList, ThreadType, Thread } from '@/components/chat/ThreadList';
import { ChatView, ChatMessage } from '@/components/chat/ChatView';
import { PullToRefresh } from '@/components/ui/PullToRefresh';
import { Button } from '@/components/ui/button';
import { useChatThreads } from '@/hooks/useChatThreads';
import { useTextChat } from '@/hooks/useTextChat';
import { useChatGestures } from '@/hooks/useChatGestures';
import { toast } from 'sonner';

export default function AgentChatScreen() {
  const navigate = useNavigate();
  const [searchParams, setSearchParams] = useSearchParams();
  const currentThreadId = searchParams.get('threadId');
  const [isRefreshing, setIsRefreshing] = useState(false);
  
  const {
    threads,
    activeThreads,
    createThread,
    addMessageToThread,
    updateMessageInThread,
    archiveThread,
    deleteThread,
    getThread
  } = useChatThreads();

  const { sendMessage, isLoading } = useTextChat();

  // Convert our thread format to ThreadList format
  const convertToThreadListFormat = (): Thread[] => {
    return threads.map(t => ({
      id: t.id,
      type: 'custom' as ThreadType,
      title: t.topic,
      lastMessage: t.messages.length > 0 
        ? t.messages[t.messages.length - 1].content 
        : 'No messages yet',
      lastMessageAt: t.lastMessageAt,
      unreadCount: 0, // Can be enhanced later
      isArchived: t.isArchived,
      createdAt: t.createdAt
    }));
  };

  // Handle creating a new thread
  const handleNewThread = useCallback((type: ThreadType) => {
    const newThread = createThread('New conversation');
    setSearchParams({ threadId: newThread.id });
    toast.success('New conversation started');
  }, [createThread, setSearchParams]);

  // Handle selecting a thread
  const handleThreadSelect = useCallback((threadId: string) => {
    setSearchParams({ threadId });
  }, [setSearchParams]);

  // Handle archiving a thread
  const handleArchiveThread = useCallback((threadId: string) => {
    archiveThread(threadId);
    toast.success('Thread archived');
    if (currentThreadId === threadId) {
      setSearchParams({});
    }
  }, [archiveThread, currentThreadId, setSearchParams]);

  // Handle deleting a thread
  const handleDeleteThread = useCallback((threadId: string) => {
    deleteThread(threadId);
    toast.success('Thread deleted');
    if (currentThreadId === threadId) {
      setSearchParams({});
    }
  }, [deleteThread, currentThreadId, setSearchParams]);

  // Handle sending a message
  const handleSendMessage = useCallback(async (content: string) => {
    if (!currentThreadId) return;

    const thread = getThread(currentThreadId);
    if (!thread) return;

    // Add user message immediately
    const userMessage: ChatMessage = {
      id: `msg-${Date.now()}`,
      role: 'user',
      content,
      timestamp: new Date(),
      status: 'sending'
    };
    addMessageToThread(currentThreadId, userMessage);

    // Update topic if this is the first message
    if (thread.messages.length === 0) {
      // Topic will be auto-generated by useChatThreads on next save
    }

    try {
      // Get full conversation history for context
      const conversationHistory = [
        ...thread.messages.map(m => ({
          role: m.role,
          content: m.content
        })),
        { role: 'user' as const, content }
      ];

      // Call Claude API with full context
      const response = await sendMessage(content, conversationHistory);

      // Add assistant response
      const assistantMessage: ChatMessage = {
        id: `msg-${Date.now() + 1}`,
        role: 'assistant',
        content: response,
        timestamp: new Date(),
        status: 'sent'
      };
      addMessageToThread(currentThreadId, assistantMessage);

    } catch (error) {
      console.error('Failed to send message:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to send message');
    }
  }, [currentThreadId, getThread, addMessageToThread, sendMessage]);

  // Handle going back from chat view
  const handleBack = useCallback(() => {
    setSearchParams({});
  }, [setSearchParams]);

  // Handle pull to refresh
  const handleRefresh = useCallback(async () => {
    setIsRefreshing(true);
    // Simulate refresh delay
    await new Promise(resolve => setTimeout(resolve, 1000));
    setIsRefreshing(false);
    toast.success('Chat refreshed');
  }, []);

  // Get current thread for chat view
  const currentThread = currentThreadId ? getThread(currentThreadId) : null;

  // Chat gesture handlers
  const { swipeHandlers, messageGestures } = useChatGestures({
    onSwipeRight: currentThread ? handleBack : undefined,
    onSwipeLeft: currentThread ? () => handleArchiveThread(currentThread.id) : undefined,
    onLongPress: (messageId) => {
      toast.info('Message options', {
        description: 'Long press detected on message',
        action: {
          label: 'Close',
          onClick: () => {}
        }
      });
    },
    onDoubleTap: (messageId) => {
      if (currentThread) {
        // Toggle important flag
        const message = currentThread.messages.find(m => m.id === messageId);
        if (message) {
          updateMessageInThread(
            currentThread.id, 
            messageId, 
            { isImportant: !message.isImportant }
          );
          toast.success(message.isImportant ? 'Unmarked as important' : 'Marked as important');
        }
      }
    }
  });

  return (
    <div className="relative min-h-screen bg-background" {...swipeHandlers}>
      <TopBar 
        variant="back" 
        title={currentThread ? currentThread.topic : "MMAgent Chat"}
        onBackClick={currentThread ? handleBack : () => navigate(-1)}
      />
      
      <ScreenContainer
        hasTopBar
        hasBottomNav={!currentThread} // Hide bottom nav in chat view
        padding={false}
        scrollable={false}
        className="h-[calc(100vh-56px)]"
      >
        <PullToRefresh onRefresh={handleRefresh}>
          {currentThread ? (
            <ChatView
              threadId={currentThread.id}
              threadType="custom"
              threadTitle={currentThread.topic}
              messages={currentThread.messages}
              onSendMessage={handleSendMessage}
              onArchive={() => handleArchiveThread(currentThread.id)}
              onDelete={() => handleDeleteThread(currentThread.id)}
              onToggleImportant={(messageId) => {
                const message = currentThread.messages.find(m => m.id === messageId);
                if (message) {
                  updateMessageInThread(
                    currentThread.id,
                    messageId,
                    { isImportant: !message.isImportant }
                  );
                }
              }}
              messageGestures={messageGestures}
              isTyping={isLoading}
              quickReplies={currentThread.messages.length === 0 ? [
                'Tell me about my matches',
                'How can I improve my profile?',
                'What makes a good match?'
              ] : []}
            />
          ) : (
            <ThreadList
              threads={convertToThreadListFormat()}
              onThreadSelect={handleThreadSelect}
              onNewThread={handleNewThread}
              onArchiveThread={handleArchiveThread}
              onDeleteThread={handleDeleteThread}
              isLoading={false}
            />
          )}
        </PullToRefresh>
      </ScreenContainer>

      {/* Floating Action Button for New Thread (only on thread list) */}
      <AnimatePresence>
        {!currentThread && (
          <motion.div
            initial={{ scale: 0, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0, opacity: 0 }}
            className="fixed bottom-20 right-4 z-50"
          >
            <Button
              size="lg"
              onClick={() => handleNewThread('custom')}
              className="h-14 w-14 rounded-full shadow-lg"
            >
              <Plus className="w-6 h-6" />
            </Button>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
